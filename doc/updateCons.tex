We want all the integer variables to be defined by one-way constraints such that the search space in local search only 
consists of binary variables. The following algorithms describe how integer variables get defined by one-way 
constraints. \\ 
let $Y$ be a list of integer variables and $y \in Y$. The subset of constraints $y(c) \subseteq C$ is the set 
of constraints where integer variable $y$ has a non zero coefficient. \\ 
\IncMargin{1em}
\begin{algorithm}[H]
\SetKwData{Oneway}{oneway}

\SetKwFunction{makeOneway}{makeOneway}
\SetKwFunction{Next}{next}\SetKwFunction{Constraints}{Constraints}\SetKwFunction{Remove}{remove}
\SetKwFunction{canBeMadeOneway}{canBeMadeOneway}
\algdata 
\Input{A List $Y$ of integer variables}
%\Output{A partition of the bitmap}
\BlankLine
%\emph{special treatment of the first line}\;
\Bool $change = true$\;
\While{$Y \neq \emptyset$ \textbf{and} $change$}{
  $change = false$ \;
  \Var $y = $ \upshape next \Var in $Y$\;
  \ForEach{\Con $c$ \upshape in $y(c)$}{
    \Bool $flag = $ \canBeMadeOneway{c,y}\;  
    \If{$flag$}{
      \makeOneway{c,y}\;
      Remove $y$ from $Y$\;
      $change = true$\;
      \bre\;
    }
  }
}
\caption{Defining integer variables by one-way constraints}\label{algo_defintvar}
\end{algorithm}\DecMargin{1em}
\noindent
The algorithm try to make all integer variables one-way. It uses two other algorithms 
\canBeMadeOneway{c,y}\ref{algo_checkoneway} and \makeOneway{c,y}\ref{algo_makeoneway}. The first algorithm check if the 
\cons $c$ can be used to define \var $y$ and the second algorithm transforms $c$ into a one-way constraint defining 
$y$. \boste{Need complexity arguments} \\ 
The coefficients of the variables in constraint $c$ are denoted $A(c)$ and the coefficients of variables in the 
objective function $f(\vec{y}) \in F$ denoted as $A(f(y))$.  \boste{Maybe call it evalutation functions} Then the 
coefficent of variable $y$ in constriant $c$ is $A(c,y)$. \\  

\IncMargin{1em}
\begin{algorithm}[H]

\SetKwFunction{relation}{relation}\SetKwFunction{coeff}{coefficient}
\SetKwFunction{objcoeff}{objectiveCoefficients}
\algdata
\Input{\Con $c$ and \Var $y$}
\Output{Boolean}
\BlankLine
\If{c \upshape defines a oneway constraint}{\Return{false}}
\If{\upshape Number of integer variables not defined $> 1$}{\Return{false}}
\If{\relation{c} == Equal}{\Return{true}}
%\int coeff = \coeff{c,v}\;
%\upshape in $\bigcup\limits_{o \in O} f_o(\vec{v})$}{
\ForEach{a \upshape in $A(f(y))$ }{
\If{$A(c,y) \cdot a > 0$}{\Return{false}}}
\Return{true}\;

 \caption{Test if a constraint $c$ can define a variable $y$ } \label{algo_checkoneway}
\end{algorithm}
\DecMargin{1em}
The variables that a constraint $c$ applies to is the scope $V(c)$. The constraints are of the type \class{Linear} and 
a constraint $c$ have a right hand side $B(c)$. \\ 
\IncMargin{1em}
\begin{algorithm}[H]
\algdata
\Input{\Con $c$ and \Var $y$}
\Output{An Invariant}
\BlankLine
\int $coef = A(c,y)$\;
$A(c) = A(c) \backslash \{A(c,y)\}$\;
$V(c) = V(c) \backslash \{y\}$\;
\ForEach{$A(c,v)$ \upshape in $A(c)$}{
  $A(c,v) = A(c,v) \cdot \frac{-1}{coef}$
}
\int $b = B(c)$ \;
\If{\relation{c} == Equal}{
  \Return{\Sum{$V(c)$,$A(c)$,b}}
}
\Else{
  Invariant $inv = $\Sum{$V(c)$,$A(c)$,b}\;
  \Return{\Max{inv,b}}
}

 \caption{Make one-way constraint from $c$ defining variable $y$ } \label{algo_makeoneway}
\end{algorithm}\DecMargin{1em}




% \floatname{algorithm}{Finding One-way constraints}
%\begin{algorithm}[ht]
% \caption{O$(|V|^2C_{mav}$O$($\method{canBeMadeOneway()}$)$}
% \begin{algorithmic}\label{updateGraph1}
%  \STATE{$Q = \emptyset$}
%  \STATE{$V = $ model.getVariables()}
%  \STATE{V.sort()}
%  \STATE{\bool change = \true }
%  \WHILE{change}
%    \FOR{\var var in $V$}
%      \FOR{\cons cons in var.usedInConstriant()}
%	\IF{\method{canBeMadeOneway(var, cons)}}
%	  \STATE{V.remove(var)}
%	  \STATE{$Q.psuhback($var$)$}
%	  \STATE{\Break }
%	\ELSE
%	\STATE{change = \false}
%	\ENDIF
%      \ENDFOR
%    \ENDFOR
%   % \STATE{layer$++$}
%%{$j\leftarrow 1$ \TO $i-1$}
%  \ENDWHILE
% \end{algorithmic}
%
%\end{algorithm}


% \floatname{algorithm}{}
%\begin{algorithm}[ht]
% \caption{\bool \method{canBeMadeOneway}(\var \text{var}, \cons cons) \qquad O$(V_{mav} + $O$($\method{makeOneway}$))$}
% \begin{algorithmic}\label{updateGraph1}
% \IF{cons.isOneway()}
%  \RETURN \false
%  \ENDIF
% \STATE{\Int notDefined = 0} 
% \FOR { \var v in cons.getVariables}
% \IF{v.isInteger()}
%  \IF{!v.isDefinedByOneway}
%  \STATE{notDefined++}
%  \ENDIF
%  \ENDIF
%  \IF{notDefined $> 1$}
%    \RETURN \false  
% \ENDIF
% \ENDFOR
% \STATE{\Int coef = var.getCoefficient(cons)}
% \STATE{\Int objCoef = var.getObjectiveCoefficient()}
% 
% \IF{cons.Relation = EQ \OR coef$\cdot$objCoef $< 0$}
%    \STATE{\method{makeOneway}(\var var, \cons cons)}
%    \RETURN \true
% \ENDIF
% \RETURN \false
% \end{algorithmic}
%\end{algorithm}


% \floatname{algorithm}{}
%\begin{algorithm}[ht]
% \caption{\method{makeOneway}(\var \text{var}, \cons cons) \qquad O$(V_{mav})$}
% \begin{algorithmic}\label{updateGraph1}
% \STATE{variables = cons.getVariables()-var}
% \STATE{coefficients = cons.getCoefficient-var.coefficients}
% \STATE{\Int coef = var.getCoefficient(cons)}
% \IF{coef $\neq$ -1}
% \STATE{coefficients = $\frac{-1}{coef}\cdot$ coefficients}
% \ENDIF
% \STATE{\invar invar$(variables, coefficients)$}
% \FOR{\var v in variables}
%  \IF{v.isDefinedByOneway}
%    \STATE{\invar inv = v.oneway}
%    \STATE{inv.updateList.pushback(invar)}
%  \ELSE
%  \STATE{v.updateList.pushback(invar)}
%  \ENDIF
%   \ENDFOR
%   \STATE{cons.isOneway = \true }
%   \STATE{cons.defines = invar }
%   \STATE{var.setDefinedBy(invar,cons)}
%   \STATE{model.add(invar)}
%   \STATE{invar.currentvalue = -cons.getArgument(1)} 
% \end{algorithmic}
%\end{algorithm}
  



