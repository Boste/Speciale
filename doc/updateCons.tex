We define as many variables to be one-way constraints as posible, starting with integer variables, such that the search 
space in local search only consists of binary variables. The following algorithms describe how one-way 
constraints a create to define a variable $x$. \\ 
Let $X$ be a set of variables and $x \in X$. The subset of constraints $C(x) \subseteq C$ is the set 
of constraints that applies to $x$.\\ 
\IncMargin{1em}
\begin{algorithm}[H]
\SetKwData{Oneway}{oneway}

\SetKwFunction{makeOneway}{makeOneway}
\SetKwFunction{Next}{next}\SetKwFunction{Constraints}{Constraints}\SetKwFunction{Remove}{remove}
\SetKwFunction{canBeMadeOneway}{canBeMadeOneway}
\algdata 
\Input{A set $X$ of variables \boste{Sorting order?}}
\Output{A model better suited for local search}
\BlankLine
%\emph{special treatment of the first line}\;
\Bool $change = $ \true\;
\While{$X \neq \emptyset$ \textbf{and} $change$}{
  $change = $\false \;
  \upshape select \Var $x$ \upshape from $X$\;
  \ForEach{\Con $c$ \upshape in $C(x)$}{
    \Bool $flag = $ \canBeMadeOneway{c,x}\;  
    \If{$flag$}{
      \makeOneway{c,x}\;
      Remove $x$ from $X$\;
      $change = \true$\;
      \bre\;
    }
  }
}
\caption{Defining integer variables by one-way constraints}\label{algo_defintvar}
\end{algorithm}\DecMargin{1em}
\noindent
The algorithm tries to make all integer variables one-way. It uses two other algorithms 
\canBeMadeOneway{c,x} and \makeOneway{c,x}. The first algorithm checks if the 
\cons $c$ can be used to define \var $x$ and the second algorithm transforms $c$ into a one-way constraint defining 
$x$. \boste{Need complexity arguments} \\ 
The coefficient of a variable $x_j$ in constraint $c_i$ is denoted $a_{ij}$. Let $\mathcal{F} = \{f_1,f_2,\dots ,\f_k$ 
be the family of objective functions and the coefficient of variable $x_j$ in $f_k$ be $a_{kj}$. \boste{Maybe call it 
evalutation functions. Does not make sense since $a_{34}$ referes both to constraint and obj. func} 		 \\  

\IncMargin{1em}
\begin{algorithm}[H]

\SetKwFunction{relation}{relation}\SetKwFunction{coeff}{coefficient}
\SetKwFunction{objcoeff}{objectiveCoefficients}
\algdata
\Input{\Con $c$ and \Var $x$}
\Output{Boolean}
\BlankLine
\If{c \upshape defines a oneway constraint}{\Return{} \false}
\If{\upshape Number of integer variables not defined $> 1$}{\Return{} \false}
\If{\relation{c} == Equal}{\Return{} \true}
%\int coeff = \coeff{c,v}\;
%\upshape in $\bigcup\limits_{o \in O} f_o(\vec{v})$}{
\ForEach{a \upshape in $A(f(x))$ }{
  \If{$A(c,x) \cdot a > 0$}{
    \Return{} \false
  }
}
\Return{} \true\;
 \caption{canBeMadeOneway(\textsf{Constraint} c, \textsf{Variable} x)} \label{algo_checkoneway}
% \caption{Test if a constraint $c$ can define a variable $x$ } \label{algo_checkoneway}
\end{algorithm}
\DecMargin{1em}
The variables that a constraint $c$ applies to is the scope $V(c)$. The constraints are of the type \class{Linear} and 
a constraint $c$ have a right hand side $B(c)$. \\ 
\IncMargin{1em}
\begin{algorithm}[H]
\algdata
\Input{\Con $c$ and \Var $x$}
\Output{An Invariant}
\BlankLine
\int $coef = A(c,x)$\;
$A(c) = A(c) \backslash \{A(c,x)\}$\;
$V(c) = V(c) \backslash \{x\}$\;
\ForEach{$A(c,v)$ \upshape in $A(c)$}{
  $A(c,v) = A(c,v) \cdot \frac{-1}{coef}$
}
\int $b = B(c)$ \;
\If{\relation{c} == Equal}{
  \Return{\Sum{$V(c)$,$A(c)$,b}}
}
\Else{
  Invariant $inv = $\Sum{$V(c)$,$A(c)$,b}\;
  \Return{\Max{inv,b}}
}

 \caption{Make one-way constraint from $c$ defining variable $x$ } \label{algo_makeoneway}
\end{algorithm}\DecMargin{1em}




% \floatname{algorithm}{Finding One-way constraints}
%\begin{algorithm}[ht]
% \caption{O$(|V|^2C_{mav}$O$($\method{canBeMadeOneway()}$)$}
% \begin{algorithmic}\label{updateGraph1}
%  \STATE{$Q = \emptyset$}
%  \STATE{$V = $ model.getVariables()}
%  \STATE{V.sort()}
%  \STATE{\bool change = \true }
%  \WHILE{change}
%    \FOR{\var var in $V$}
%      \FOR{\cons cons in var.usedInConstriant()}
%	\IF{\method{canBeMadeOneway(var, cons)}}
%	  \STATE{V.remove(var)}
%	  \STATE{$Q.psuhback($var$)$}
%	  \STATE{\Break }
%	\ELSE
%	\STATE{change = \\false}
%	\ENDIF
%      \ENDFOR
%    \ENDFOR
%   % \STATE{laxer$++$}
%%{$j\leftarrow 1$ \TO $i-1$}
%  \ENDWHILE
% \end{algorithmic}
%
%\end{algorithm}


% \floatname{algorithm}{}
%\begin{algorithm}[ht]
% \caption{\bool \method{canBeMadeOneway}(\var \text{var}, \cons cons) \qquad O$(V_{mav} + $O$($\method{makeOneway}$))$}
% \begin{algorithmic}\label{updateGraph1}
% \IF{cons.isOneway()}
%  \RETURN \\false
%  \ENDIF
% \STATE{\Int notDefined = 0} 
% \FOR { \var v in cons.getVariables}
% \IF{v.isInteger()}
%  \IF{!v.isDefinedBxOneway}
%  \STATE{notDefined++}
%  \ENDIF
%  \ENDIF
%  \IF{notDefined $> 1$}
%    \RETURN \\false  
% \ENDIF
% \ENDFOR
% \STATE{\Int coef = var.getCoefficient(cons)}
% \STATE{\Int objCoef = var.getObjectiveCoefficient()}
% 
% \IF{cons.Relation = EQ \OR coef$\cdot$objCoef $< 0$}
%    \STATE{\method{makeOneway}(\var var, \cons cons)}
%    \RETURN \true
% \ENDIF
% \RETURN \\false
% \end{algorithmic}
%\end{algorithm}


% \floatname{algorithm}{}
%\begin{algorithm}[ht]
% \caption{\method{makeOneway}(\var \text{var}, \cons cons) \qquad O$(V_{mav})$}
% \begin{algorithmic}\label{updateGraph1}
% \STATE{variables = cons.getVariables()-var}
% \STATE{coefficients = cons.getCoefficient-var.coefficients}
% \STATE{\Int coef = var.getCoefficient(cons)}
% \IF{coef $\neq$ -1}
% \STATE{coefficients = $\frac{-1}{coef}\cdot$ coefficients}
% \ENDIF
% \STATE{\invar invar$(variables, coefficients)$}
% \FOR{\var v in variables}
%  \IF{v.isDefinedBxOneway}
%    \STATE{\invar inv = v.oneway}
%    \STATE{inv.updateList.pushback(invar)}
%  \ELSE
%  \STATE{v.updateList.pushback(invar)}
%  \ENDIF
%   \ENDFOR
%   \STATE{cons.isOneway = \true }
%   \STATE{cons.defines = invar }
%   \STATE{var.setDefinedBx(invar,cons)}
%   \STATE{model.add(invar)}
%   \STATE{invar.currentvalue = -cons.getArgument(1)} 
% \end{algorithmic}
%\end{algorithm}
  



